======================================================================
AUTOMATED FEEDBACK LOG
======================================================================

HOW TO READ THIS FEEDBACK:
--------------------------
1. This log contains detailed feedback on your code execution
2. Each script is tested and results are shown with output and errors
3. IMPORTANT: Read all the way to the END for a summary and debugging guidance
4. The summary at the end will help you understand and fix any issues
5. Scripts are run in a headless environment (no GUI applications)

======================================================================

Starting testing for Ximan Ding

Processing all weeks found in repository

Your current Git repo size is about 63.05 MiB on disk

Found directories: .git, week1, week4, week2, .ipynb_checkpoints, myenv, Feedback, week3
Found files: .gitignore, .RData, .Rhistory, README.md, Untitled.ipynb

Processing all weeks: week1, week4, week2, week3

Found 46 code files to test.

Note: Expected file checking not performed (no FileList provided).
Expected file checking will only be performed during final assessment.

======================================================================
Script: csvtospace.sh

Contents:

**********
#!/bin/sh
# Author:  Ximan Ding<x.ding25@imperial.ac.uk>
# Script: csvtospace.sh
# Desc: Convert a comma-separated file to a space-separated file.
#       Does NOT modify the input; writes alongside it as <basename>.space
# Usage: bash csvtospace.sh <csv_file>
# Date: Oct 2025

set -u

usage() { echo "Usage: bash $0 <csv_file>"; exit 1; }

[ $# -eq 1 ] || usage

in="$1"
[ -f "$in" ] || { echo "Error: '$in' not found or not a regular file."; exit 2; }

dir=$(dirname "$in")
base=$(basename "$in")
name="${base%.*}"
out="$dir/$name.space"

if [ -e "$out" ]; then
  echo "Error: output '$out' already exists. Refusing to overwrite."
  exit 3
fi

echo "Converting commas to spaces: $in -> $out"
tr ',' ' ' < "$in" | tr -s ' ' > "$out" || { echo "Conversion failed."; exit 4; }

echo "Done: $out"

**********

Output (first 500 chars):

**********
Usage: bash csvtospace.sh <csv_file>

**********
No errors.
======================================================================
Script: CompileLaTeX.sh

Contents:

**********
#!/bin/bash
pdflatex $1.tex
bibtex $1
pdflatex $1.tex
pdflatex $1.tex
evince $1.pdf &

## Cleanup
rm *.aux
rm *.log
rm *.bbl
rm *.blg

**********

Output (first 500 chars):

**********
This is pdfTeX, Version 3.141592653-2.6-1.40.25 (TeX Live 2023/Debian) (preloaded format=pdflatex)
 restricted \write18 enabled.
entering extended mode
(/usr/share/texlive/texmf-dist/tex/latex/tools/.tex
LaTeX2e <2023-11-01> patch level 1
L3 programming layer <2024-01-22>
File ignored)
*
! Emergency stop.
<*> 
    
!  ==> Fatal error occurred, no output PDF file produced!
Transcript written on .log.
This is pdfTeX, Version 3.141592653-2.6-1.40.25 (TeX Live 2023/Debian) (preloaded format=pdflatex
**********
Errors:
**********
bibtex: Need exactly one file argument.
Try `bibtex --help' for more information.
rm: cannot remove '*.aux': No such file or directory
rm: cannot remove '*.log': No such file or directory
rm: cannot remove '*.bbl': No such file or directory
rm: cannot remove '*.blg': No such file or directory
Cannot parse arguments: Cannot open display: 

**********
======================================================================
Script: tiff2png.sh

Contents:

**********
#!/bin/bash

for f in *.tif; 
    do  
        echo "Converting $f"; 
        convert "$f"  "$(basename "$f" .tif).png"; 
    done

**********

Output (first 500 chars):

**********
Converting *.tif

**********
Errors:
**********
convert-im6.q16: unable to open image `*.tif': No such file or directory @ error/blob.c/OpenBlob/2964.
convert-im6.q16: no images defined `*.png' @ error/convert.c/ConvertImageCommand/3234.

**********
======================================================================
Script: boilerplate.sh

Contents:

**********
#!/bin/sh
# Author: x.ding25@imperial.ac.uk
# Script: boilerplate.sh
# Desc: simple boilerplate for shell scripts
# Arguments: none
# Date: Oct 2025

echo -e "\nThis is a shell script! \n"

#exit

**********

Output (first 500 chars):

**********

This is a shell script! 


**********
No errors.
======================================================================
Script: ConcatenateTwoFiles.sh

Contents:

**********
#!/bin/bash

cat $1 > $3
cat $2 >> $3
echo "Merged File is"
cat $3

**********

Output (first 500 chars):

**********
Merged File is

**********
Errors:
**********
ConcatenateTwoFiles.sh: line 3: $3: ambiguous redirect
ConcatenateTwoFiles.sh: line 4: $3: ambiguous redirect

**********
======================================================================
Script: tabtocsv.sh

Contents:

**********
#!/bin/sh
# Author: Your name you.login@imperial.ac.uk
# Script: tabtocsv.sh
# Description: substitute the tabs in the files with commas
#
# Saves the output into a .csv file
# Arguments: 1 -> tab delimited file
# Date: Oct 2019

echo "Creating a comma delimited version of $1 ..."
cat $1 | tr -s "\t" "," >> $1.csv
echo "Done!"
exit

**********

Output (first 500 chars):

**********
Creating a comma delimited version of  ...
Done!

**********
No errors.
======================================================================
Script: variables.sh

Contents:

**********
#!/bin/sh

## Illustrates the use of variables 

# Special variables

echo "This script was called with $# parameters"
echo "The script's name is $0"
echo "The arguments are $@"
echo "The first argument is $1"
echo "The second argument is $2"

# Assigned Variables; Explicit declaration:
MY_VAR='some string' 
echo 'the current value of the variable is:' $MY_VAR
echo
echo 'Please enter a new string'
read MY_VAR
echo
echo 'the current value of the variable is:' $MY_VAR
echo

## Assigned Variables; Reading (multiple values) from user input:
echo 'Enter two numbers separated by space(s)'
read a b
echo
echo 'you entered' $a 'and' $b '; Their sum is:'

## Assigned Variables; Command substitution
MY_SUM=$(expr $a + $b)
echo $MY_SUM


**********

Output (first 500 chars):

**********
This script was called with 0 parameters
The script's name is variables.sh
The arguments are 
The first argument is 
The second argument is 
the current value of the variable is: some string

Please enter a new string

the current value of the variable is:

Enter two numbers separated by space(s)

you entered and ; Their sum is:


**********
Errors:
**********
expr: syntax error: missing argument after ‘+’

**********
======================================================================
Script: CountLines.sh

Contents:

**********
#!/bin/bash

NumLines=`wc -l < $1`
echo "The file $1 has $NumLines lines"
echo

**********

Output (first 500 chars):

**********
The file  has  lines


**********
Errors:
**********
CountLines.sh: line 3: $1: ambiguous redirect

**********
======================================================================
Script: VisualizingRegressionAnalyses.R

Contents:

**********
# Visualizing Regression analyses — subset by Predator.lifestage
# 输出：results/regressions_by_lifestage.csv  和  results/predator_prey_regressions.pdf

# —— 依赖包 —— #
pkgs <- c("tidyverse","broom")
invisible(lapply(pkgs, function(p) if (!requireNamespace(p, quietly = TRUE)) install.packages(p)))
library(tidyverse)
library(broom)

# —— I/O 路径（可按需修改）—— #
infile  <- "../data/EcolArchives-E089-51-D1.csv"
outdir  <- "results"
outfile_csv <- file.path(outdir, "regressions_by_lifestage.csv")
outfile_pdf <- file.path(outdir, "predator_prey_regressions.pdf")

if (!dir.exists(outdir)) dir.create(outdir, recursive = TRUE)

# —— 读数与清洗 —— #
df <- read.csv(infile, stringsAsFactors = FALSE)

# 只保留分析所需变量，并统一类型
df <- df %>%
  transmute(
    Predator.lifestage = as.factor(Predator.lifestage),
    Predator.mass      = as.numeric(Predator.mass),
    Prey.mass          = as.numeric(Prey.mass),
    Prey.mass.unit     = Prey.mass.unit
  )

# 单位统一：mg → g
df$Prey.mass[df$Prey.mass.unit == "mg"] <- df$Prey.mass[df$Prey.mass.unit == "mg"] / 1000
df$Prey.mass.unit <- "g"

# 过滤缺失与非正数（log10 需要）
dat <- df %>%
  filter(is.finite(Predator.mass), is.finite(Prey.mass),
         Predator.mass > 0, Prey.mass > 0,
         !is.na(Predator.lifestage))

# 添加对数列
dat <- dat %>%
  mutate(
    log10Pred = log10(Predator.mass),
    log10Prey = log10(Prey.mass)
  )

# —— 按生命阶段分组回归：log10(Prey) ~ log10(Predator) —— #
models <- dat %>%
  group_by(Predator.lifestage) %>%
  group_map(~ lm(log10Prey ~ log10Pred, data = .x), .keep = TRUE)

names(models) <- levels(dat$Predator.lifestage)

# 整理系数表 & 模型摘要
coef_tbl <- map2_dfr(
  models, names(models),
  ~ tidy(.x) %>%
    mutate(Predator.lifestage = .y) %>%
    select(Predator.lifestage, term, estimate, std.error, statistic, p.value)
)

glance_tbl <- map2_dfr(
  models, names(models),
  ~ glance(.x) %>%
    mutate(Predator.lifestage = .y) %>%
    select(Predator.lifestage, r.squared, adj.r.squared, sigma, AIC, BIC, df = df.residual, p.value)
)

n_tbl <- dat %>%
  count(Predator.lifestage, name = "n")

# 合并成一个清晰结果表：每组给出截距与斜率行各一条，也可透视成宽表
res_long <- coef_tbl %>%
  left_join(glance_tbl, by = "Predator.lifestage") %>%
  left_join(n_tbl, by = "Predator.lifestage") %>%
  arrange(Predator.lifestage, match(term, c("(Intercept)", "log10Pred")))

# 也提供一个“宽表”（每组一行：斜率、截距、R2、N等）
res_wide <- res_long %>%
  select(Predator.lifestage, term, estimate, std.error, statistic, p.value,
         r.squared, adj.r.squared, sigma, AIC, BIC, df, n) %>%
  pivot_wider(
    names_from = term,
    values_from = c(estimate, std.error, statistic, p.value),
    names_glue = "{term}.{.value}"
  ) %>%
  # 便于阅读重命名
  rename(
    intercept      = `(Intercept).estimate`,
    slope          = `log10Pred.estimate`,
    intercept_se   = `(Intercept).std.error`,
    slope_se       = `log10Pred.std.error`,
    intercept_t    = `(Intercept).statistic`,
    slope_t        = `log10Pred.statistic`,
    intercept_p    = `(Intercept).p.value`,
    slope_p        = `log10Pred.p.value`
  ) %>%
  arrange(Predator.lifestage)

# 写出 CSV（含宽表，附在下方；若你只想要 res_long，把对象换掉即可）
write.csv(res_wide, outfile_csv, row.names = FALSE)

# —— 画图：按生命阶段分面，散点 + 回归线 —— #
p <- ggplot(dat, aes(x = log10Pred, y = log10Prey)) +
  geom_point(alpha = 0.35, size = 1) +
  geom_smooth(method = "lm", se = FALSE, linewidth = 0.8) +
  facet_wrap(~ Predator.lifestage, scales = "free") +
  labs(
    x = expression(log[10]*"(Predator mass, g)"),
    y = expression(log[10]*"(Prey mass, g)"),
    title = "Predator–Prey body mass regressions by predator lifestage"
  ) +
  theme_bw(base_size = 12) +
  theme(panel.grid = element_blank())

ggsave(outfile_pdf, p, width = 9, height = 6, units = "in", dpi = 300)

message("Done.\nCSV: ", outfile_csv, "\nPDF: ", outfile_pdf)



**********

Output (first 500 chars):

**********

**********
Errors:
**********
── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──
✔ dplyr     1.1.4     ✔ readr     2.1.5
✔ forcats   1.0.0     ✔ stringr   1.5.1
✔ ggplot2   3.4.4     ✔ tibble    3.3.0
✔ lubridate 1.9.4     ✔ tidyr     1.3.1
✔ purrr     1.0.4     
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors
Error in file(file, "rt") : cannot open the connection
Calls: read.csv -> read.table -> file
In addition: Warning message:
In file(file, "rt") :
  cannot open file '../data/EcolArchives-E089-51-D1.csv': No such file or directory
Execution halted

**********
======================================================================
Script: MyExampleScript.py

Contents:

**********
#MyExampleScript.py
def foo(x):
    """Print x squared (side effect)."""
    x *= x  # same as x = x * x
    print(x)

if __name__ == "__main__":
    foo(2)

**********

Output (first 500 chars):

**********
4

**********
No errors.
======================================================================
Script: lc2.py

Contents:

**********
# cfexercises2.py
# This is only the code file.
# All my understanding of these code below, with my prediction of how many hello will be printed, are shown in my week2 readme file. 
########################
def hello_1(x):
    for j in range(x):
        if j % 3 == 0:
            print('hello')
    print(' ')

hello_1(12)

########################
def hello_2(x):
    for j in range(x):
        if j % 5 == 3:
            print('hello')
        elif j % 4 == 3:
            print('hello')
    print(' ')

hello_2(12)

########################
def hello_3(x, y):
    for i in range(x, y):
        print('hello')
    print(' ')

hello_3(3, 17)

########################
def hello_4(x):
    while x != 15:
        print('hello')
        x = x + 3
    print(' ')

hello_4(0)

########################
def hello_5(x):
    while x < 100:
        if x == 31:
            for k in range(7):
                print('hello')
        elif x == 18:
            print('hello')
        x = x + 1
    print(' ')

hello_5(12)

# WHILE loop with BREAK
def hello_6(x, y):
    while x: # while x is True
        print("hello! " + str(y))
        y += 1 # increment y by 1 
        if y == 6:
            break
    print(' ')

hello_6 (True, 0)
**********

Output (first 500 chars):

**********
hello
hello
hello
hello
 
hello
hello
hello
hello
 
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
 
hello
hello
hello
hello
hello
 
hello
hello
hello
hello
hello
hello
hello
hello
 
hello! 0
hello! 1
hello! 2
hello! 3
hello! 4
hello! 5
 

**********
No errors.
======================================================================
Script: oaks.py

Contents:

**********
## Finds just those taxa that are oak trees from a list of species

taxa = [ 'Quercus robur',
         'Fraxinus excelsior',
         'Pinus sylvestris',
         'Quercus cerris',
         'Quercus petraea',
       ]

def is_an_oak(name):
    return name.lower().startswith('quercus ')

##Using for loops
oaks_loops = set()
for species in taxa:
    if is_an_oak(species):
        oaks_loops.add(species)
print(oaks_loops)

##Using list comprehensions   
oaks_lc = set([species for species in taxa if is_an_oak(species)])
print(oaks_lc)

##Get names in UPPER CASE using for loops
oaks_loops = set()
for species in taxa:
    if is_an_oak(species):
        oaks_loops.add(species.upper())
print(oaks_loops)

##Get names in UPPER CASE using list comprehensions
oaks_lc = set([species.upper() for species in taxa if is_an_oak(species)])
print(oaks_lc)
**********

Output (first 500 chars):

**********
{'Quercus robur', 'Quercus petraea', 'Quercus cerris'}
{'Quercus robur', 'Quercus petraea', 'Quercus cerris'}
{'QUERCUS PETRAEA', 'QUERCUS ROBUR', 'QUERCUS CERRIS'}
{'QUERCUS PETRAEA', 'QUERCUS ROBUR', 'QUERCUS CERRIS'}

**********
No errors.
======================================================================
Script: dictionary.py

Contents:

**********
# dictionary.py
# Only code in this document, all understanding of the code are in readme file.
GenomeSize = {'Homo sapiens': 3200.0, 'Escherichia coli': 4.6, 'Arabidopsis thaliana': 157.0}
print(GenomeSize)

print(GenomeSize['Arabidopsis thaliana'])

GenomeSize['Saccharomyces cerevisiae'] = 12.1
print(GenomeSize)

GenomeSize['Escherichia coli'] = 4.6 
print(GenomeSize)

GenomeSize['Homo sapiens'] = 3201.1
print(GenomeSize)

# Define a dictionary with duplicate keys
my_dict = {'a': 1, 'b': 2, 'a': 3}

# Print the dictionary
print(my_dict)
**********

Output (first 500 chars):

**********
{'Homo sapiens': 3200.0, 'Escherichia coli': 4.6, 'Arabidopsis thaliana': 157.0}
157.0
{'Homo sapiens': 3200.0, 'Escherichia coli': 4.6, 'Arabidopsis thaliana': 157.0, 'Saccharomyces cerevisiae': 12.1}
{'Homo sapiens': 3200.0, 'Escherichia coli': 4.6, 'Arabidopsis thaliana': 157.0, 'Saccharomyces cerevisiae': 12.1}
{'Homo sapiens': 3201.1, 'Escherichia coli': 4.6, 'Arabidopsis thaliana': 157.0, 'Saccharomyces cerevisiae': 12.1}
{'a': 3, 'b': 2}

**********
No errors.
======================================================================
Script: cfexercises2.py

Contents:

**********
# cfexercises2.py
# This is only the code file.
# All my understanding of these code below, with my prediction of how many hello will be printed, are shown in my week2 readme file. 
########################
def hello_1(x):
    for j in range(x):
        if j % 3 == 0:
            print('hello')
    print(' ')

hello_1(12)

########################
def hello_2(x):
    for j in range(x):
        if j % 5 == 3:
            print('hello')
        elif j % 4 == 3:
            print('hello')
    print(' ')

hello_2(12)

########################
def hello_3(x, y):
    for i in range(x, y):
        print('hello')
    print(' ')

hello_3(3, 17)

########################
def hello_4(x):
    while x != 15:
        print('hello')
        x = x + 3
    print(' ')

hello_4(0)

########################
def hello_5(x):
    while x < 100:
        if x == 31:
            for k in range(7):
                print('hello')
        elif x == 18:
            print('hello')
        x = x + 1
    print(' ')

hello_5(12)

# WHILE loop with BREAK
def hello_6(x, y):
    while x: # while x is True
        print("hello! " + str(y))
        y += 1 # increment y by 1 
        if y == 6:
            break
    print(' ')

hello_6 (True, 0)
**********

Output (first 500 chars):

**********
hello
hello
hello
hello
 
hello
hello
hello
hello
 
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
 
hello
hello
hello
hello
hello
 
hello
hello
hello
hello
hello
hello
hello
hello
 
hello! 0
hello! 1
hello! 2
hello! 3
hello! 4
hello! 5
 

**********
No errors.
======================================================================
Script: using_name.py

Contents:

**********
#!/usr/bin/env python3
# Filename: using_name.py

if __name__ == '__main__':
    print('This program is being run by itself!')
else:
    print('I am being imported from another script/program/module!')

print("This module's name is: " + __name__)
**********

Output (first 500 chars):

**********
This program is being run by itself!
This module's name is: __main__

**********
No errors.
======================================================================
Script: basic_io3.py

Contents:

**********
#############################
# STORING OBJECTS
#############################
# To save an object (even complex) for later use
my_dictionary = {"a key": 10, "another key": 11}

import pickle

f = open('../sandbox/testp.p','wb') ## note the b: accept binary files
pickle.dump(my_dictionary, f)
f.close()

## Load the data again
f = open('../sandbox/testp.p','rb')
another_dictionary = pickle.load(f)
f.close()

print(another_dictionary)

**********

Output (first 500 chars):

**********
{'a key': 10, 'another key': 11}

**********
No errors.
======================================================================
Script: basic_io1.py

Contents:

**********
#############################
# FILE INPUT
#############################
# Open a file for reading
f = open('../sandbox/test.txt', 'r')
# use "implicit" for loop:
# if the object is a file, python will cycle over lines
for line in f:
    print(line)

# close the file
f.close()

# Same example, skip blank lines
f = open('../sandbox/test.txt', 'r')
for line in f:
    if len(line.strip()) > 0:
        print(line)

f.close()

**********

Output (first 500 chars):

**********
First Line

Second Line



Third Line



Fourth Line
First Line

Second Line

Third Line

Fourth Line

**********
No errors.
======================================================================
Script: cfexercises1.py

Contents:

**********
# This is only the ocde file.
# All my understanding of these code below are shown in my week2 readme file. 
# cfexercises1.py
def foo_1(x):
    return x ** 0.5

def foo_2(x, y):
    if x > y:
        return x
    return y

def foo_3(x, y, z):
    if x > y:
        x, y = y, x
    if x > z:
        x, z = z, x
    if y > z:
        y, z = z, y
    return [x, y, z]

def foo_4(x):
    result = 1
    for i in range(1, x + 1):
        result = result * i
    return result

def foo_5(x): # a recursive function that calculates the factorial of x
    if x ==0 or x == 1:
        return 1
    return x * foo_5(x - 1)
     
def foo_6(x): # Calculate the factorial of x in a different way; no if statement involved
    facto = 1
    if x == o:
        return 1
    while x >= 1:
        facto = facto * x
        x = x - 1
    return facto
**********

Output (first 500 chars):

**********

**********
No errors.
======================================================================
Script: debugme.py

Contents:

**********
def buggyfunc(x):
    y = x
    for i in range(x):
        y = y-1
        z = x/y
    return z

buggyfunc(20)
**********

Output (first 500 chars):

**********

**********
Errors:
**********
Traceback (most recent call last):
  File "/home/mhasoba/Documents/Teaching/IC_CMEE/2025-26/Coursework/StudentRepos/XimanDing_xd1025/week2/code/debugme.py", line 8, in <module>
    buggyfunc(20)
  File "/home/mhasoba/Documents/Teaching/IC_CMEE/2025-26/Coursework/StudentRepos/XimanDing_xd1025/week2/code/debugme.py", line 5, in buggyfunc
    z = x/y
        ~^~
ZeroDivisionError: division by zero

**********
======================================================================
Script: boilerplate.py

Contents:

**********
#!/usr/bin/env python3

"""Description of this program or application.
You can use several lines"""

__appname__ = '[application name here]'
__author__ = 'Your Name (your@email.address)'
__version__ = '0.0.1'
__license__ = "License for this code/program"

## imports ##
import sys # module to interface our program with the operating system

## constants ##


## functions ##
def main(argv):
    """ Main entry point of the program """
    print('This is a boilerplate') # NOTE: indented using two tabs or 4 spaces
    return 0

if __name__ == "__main__": 
    """Makes sure the "main" function is called from command line"""  
    status = main(sys.argv)
    sys.exit(status)
**********

Output (first 500 chars):

**********
This is a boilerplate

**********
No errors.
======================================================================
Script: basic_io2.py

Contents:

**********
#############################
# FILE OUTPUT
#############################
# Save the elements of a list to a file
list_to_save = range(100)

f = open('../sandbox/testout.txt','w')
for i in list_to_save:
    f.write(str(i) + '\n') ## Add a new line at the end

f.close()
**********

Output (first 500 chars):

**********

**********
No errors.
======================================================================
Script: control_flow_lc1.py

Contents:

**********
# This is only the ocde file.
# All my understanding of these code below are shown in my week2 readme file. 
# cfexercises1.py
#!/usr/bin/env python3

"""Some functions exemplifying the use of control statements"""
#docstrings are considered part of the running code (normal comments are
#stripped). Hence, you can access your docstrings at run time.
__author__ = 'Ximan Ding (x.ding25@imperial.ac.uk)'
__version__ = '0.0.1'

def foo_1(x):
    return x ** 0.5

def foo_2(x, y):
    if x > y:
        return x
    return y

def foo_3(x, y, z):
    if x > y:
        x, y = y, x
    if x > z:
        x, z = z, x
    if y > z:
        y, z = z, y
    return [x, y, z]

def foo_4(x):
    result = 1
    for i in range(1, x + 1):
        result = result * i
    return result

def foo_5(x): # a recursive function that calculates the factorial of x
    if x ==0 or x == 1:
        return 1
    return x * foo_5(x - 1)
     
def foo_6(x): # Calculate the factorial of x in a different way; no if statement involved
    facto = 1
    if x == 0:
        return 1
    while x >= 1:
        facto = facto * x
        x = x - 1
    return facto

# like the program-with-control-flows example in the book, in the book they copy and rename boilerplate.py to control_flow.py
# here I will use the same way to test my functions in lc1.py
if __name__ == "__main__":
    try:
        n = int(input("Enter a non-negative integer n for tests (e.g., 5): "))
        if n < 0:
            raise ValueError("n must be non-negative")
    except Exception as e:
        print(f"[Input error] {e}. Using default n = 5")
        n = 5

    print(f"foo_1({n}) =", foo_1(n))
    print(f"foo_2({n}, 7) =", foo_2(n, 7))
    print(f"foo_3({n}, 2, 9) =", foo_3(n, 2, 9))
    print(f"foo_4({n}) =", foo_4(n))
    print(f"foo_5({n}) =", foo_5(n))
    print(f"foo_6({n}) =", foo_6(n))
        # Additional tests
    print("\n[Extra tests]")
    print("foo_5(10) =", foo_5(10))
    print("foo_6(10) =", foo_6(10))

**********

Output (first 500 chars):

**********
Enter a non-negative integer n for tests (e.g., 5): [Input error] EOF when reading a line. Using default n = 5
foo_1(5) = 2.23606797749979
foo_2(5, 7) = 7
foo_3(5, 2, 9) = [2, 5, 9]
foo_4(5) = 120
foo_5(5) = 120
foo_6(5) = 120

[Extra tests]
foo_5(10) = 3628800
foo_6(10) = 3628800

**********
No errors.
======================================================================
Script: control_flow.py

Contents:

**********
#!/usr/bin/env python3

"""Description of this program or application.
You can use several lines"""

__appname__ = '[application name here]'
__author__ = 'Your Name (your@email.address)'
__version__ = '0.0.1'
__license__ = "License for this code/program"

## imports ##
import sys # module to interface our program with the operating system

## constants ##


## functions ##
def main(argv):
    """ Main entry point of the program """
    print('This is a boilerplate') # NOTE: indented using two tabs or 4 spaces
    return 0

if __name__ == "__main__": 
    """Makes sure the "main" function is called from command line"""  
    status = main(sys.argv)
    sys.exit(status)

#!/usr/bin/env python3

"""Some functions exemplifying the use of control statements"""
#docstrings are considered part of the running code (normal comments are
#stripped). Hence, you can access your docstrings at run time.
__author__ = 'Samraat Pawar (s.pawar@imperial.ac.uk)'
__version__ = '0.0.1'

import sys

def even_or_odd(x=0): # if not specified, x should take value 0.

    """Find whether a number x is even or odd."""
    if x % 2 == 0: #The conditional if
        return f"{x} is Even!"
    return f"{x} is Odd!"

def largest_divisor_five(x=120):
    """Find which is the largest divisor of x among 2,3,4,5."""
    largest = 0
    if x % 5 == 0:
        largest = 5
    elif x % 4 == 0: #means "else, if"
        largest = 4
    elif x % 3 == 0:
        largest = 3
    elif x % 2 == 0:
        largest = 2
    else: # When all other (if, elif) conditions are not met
        return f"No divisor found for {x}!" # Each function can return a value or a variable.
    return f"The largest divisor of {x} is {largest}"

def is_prime(x=70):
    """Find whether an integer is prime."""
    for i in range(2, x): #  "range" returns a sequence of integers
        if x % i == 0:
            print(f"{x} is not a prime: {i} is a divisor") 
            return False
    print(f"{x} is a prime!")
    return True 

def find_all_primes(x=22):
    """Find all the primes up to x"""
    allprimes = []
    for i in range(2, x + 1):
        if is_prime(i):
            allprimes.append(i)
    print(f"There are {len(allprimes)} primes between 2 and {x}")
    return allprimes
      
def main(argv):
    print(even_or_odd(22))
    print(even_or_odd(33))
    print(largest_divisor_five(120))
    print(largest_divisor_five(121))
    print(is_prime(60))
    print(is_prime(59))
    print(find_all_primes(100))
    return 0

if (__name__ == "__main__"):
    status = main(sys.argv)
    sys.exit(status)
**********

Output (first 500 chars):

**********
This is a boilerplate

**********
No errors.
======================================================================
Script: lc1.py

Contents:

**********
# This is only the ocde file.
# All my understanding of these code below are shown in my week2 readme file. 
# cfexercises1.py
def foo_1(x):
    return x ** 0.5

def foo_2(x, y):
    if x > y:
        return x
    return y

def foo_3(x, y, z):
    if x > y:
        x, y = y, x
    if x > z:
        x, z = z, x
    if y > z:
        y, z = z, y
    return [x, y, z]

def foo_4(x):
    result = 1
    for i in range(1, x + 1):
        result = result * i
    return result

def foo_5(x): # a recursive function that calculates the factorial of x
    if x ==0 or x == 1:
        return 1
    return x * foo_5(x - 1)
     
def foo_6(x): # Calculate the factorial of x in a different way; no if statement involved
    facto = 1
    if x == 0:
        return 1
    while x >= 1:
        facto = facto * x
        x = x - 1
    return facto
**********

Output (first 500 chars):

**********

**********
No errors.
======================================================================
Script: test_control_flow_lc1.py

Contents:

**********
#!/usr/bin/env python3

"""Some functions exemplifying the use of control statements"""

__author__ = 'Ximan Ding (x.ding25@imperial.ac.uk)'
__version__ = '0.0.1'

import sys
import doctest  # Import the doctest module


def even_or_odd(x=0):
    """Find whether a number x is even or odd.
      
    >>> even_or_odd(10)
    '10 is Even!'
    
    >>> even_or_odd(5)
    '5 is Odd!'
        
    in case of negative numbers, the positive is taken:    
    >>> even_or_odd(-2)
    '-2 is Even!'
    """
    # Define function to be tested
    if x % 2 == 0:
        return f"{x} is Even!"
    return f"{x} is Odd!"


def main(argv):
    """Main function to demonstrate function output"""
    print(even_or_odd(22))
    print(even_or_odd(33))
    return 0


if __name__ == "__main__":
    status = main(sys.argv)

# Run the doctest embedded in the docstring
doctest.testmod()
**********

Output (first 500 chars):

**********
22 is Even!
33 is Odd!

**********
No errors.
======================================================================
Script: sysargv.py

Contents:

**********
#sysargv.py
#!/usr/bin/env python3

import sys
print("This is the name of the script: ", sys.argv[0])
print("Number of arguments: ", len(sys.argv))
print("The arguments are: " , str(sys.argv))

**********

Output (first 500 chars):

**********
This is the name of the script:  sysargv.py
Number of arguments:  1
The arguments are:  ['sysargv.py']

**********
No errors.
======================================================================
Script: oaks_debugme.py

Contents:

**********
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import csv
import sys
import re
from typing import Iterable

def _levenshtein_dist(a: str, b: str) -> int:
    la, lb = len(a), len(b)
    dp = list(range(lb + 1))
    for i in range(1, la + 1):
        prev, dp[0] = dp[0], i
        for j in range(1, lb + 1):
            cur = dp[j]
            cost = 0 if a[i - 1] == b[j - 1] else 1
            dp[j] = min(
                dp[j] + 1,        # deletion
                dp[j - 1] + 1,    # insertion
                prev + cost       # substitution
            )
            prev = cur
    return dp[lb]

def _first_alpha_token(name: str) -> str:
    
    # Keep only letters and separators as spaces, then split
    cleaned = re.sub(r"[^A-Za-z]+", " ", name).strip()
    return cleaned.split()[0] if cleaned else ""

def is_an_oak(name: str) -> bool:
    """
    Return True if the input belongs to genus Quercus (oak).
    Robust to common typos such as 'Quercuss' (one extra 's') and to
    case/whitespace/punctuation noise.

    The logic:
      - Take the first alphabetic token as the genus candidate.
      - Exact match 'quercus' => True
      - Otherwise, allow Levenshtein distance <= 1 to 'quercus'.

    >>> is_an_oak('Quercus robur')
    True
    >>> is_an_oak('quercus petraea')
    True
    >>> is_an_oak(' Quercuss  cerris ')
    True
    >>> is_an_oak('Fagus sylvatica')
    False
    >>> is_an_oak('Pinus')
    False
    >>> is_an_oak('Quercus')
    True
    >>> is_an_oak("Q. robur")  # not strictly the full genus, should be False here
    False
    >>> is_an_oak("Quercu")    # missing 's' => distance 1 -> True by our tolerant rule
    True
    """
    token = _first_alpha_token(name).lower()
    if not token:
        return False
    if token == "quercus":
        return True
    # allow one edit away (handles 'quercuss', 'quercu', 'quer cus' etc.)
    return _levenshtein_dist(token, "quercus") <= 1

def filter_oaks(rows: Iterable[Iterable[str]]) -> Iterable[tuple[str, str]]:
 
    for row in rows:
        if not row:
            continue
        genus = row[0].strip()
        if genus.lower() == "genus":
            # header row
            continue
        species = row[1].strip() if len(row) > 1 else ""
        if is_an_oak(genus):
            yield (genus, species)

def main(argv):
    in_path = "../data/TestOaksData.csv"
    out_path = "../data/JustOaksData.csv"  

    with open(in_path, "r", newline="", encoding="utf-8") as f, \
         open(out_path, "w", newline="", encoding="utf-8") as g:
        reader = csv.reader(f)
        writer = csv.writer(g)

        for row in reader:
            # Optional: print for debugging
            # print(row)
            # print("The genus is:", row[0] if row else "")
            for genus, species in filter_oaks([row]):
                # Found an oak
                # print("FOUND AN OAK!")
                writer.writerow([genus, species])

    return 0

if __name__ == "__main__":
    # To run doctests:  python3 -m doctest -v oaks_debugme.py
    sys.exit(main(sys.argv))
**********

Output (first 500 chars):

**********

**********
No errors.
======================================================================
Script: tuple.py

Contents:

**********
# tuple.py
# Only code in here, understanding of the code are in readme file.
MyTuple = ("a", "b", "c")
print(MyTuple)

print(type(MyTuple))

MyTuple[0]
print(len(MyTuple))

FoodWeb=[('a','b'),('a','c'),('b','c'),('c','c')]
print(FoodWeb)

print(FoodWeb[0])

print(FoodWeb[0][0])

FoodWeb[0] = ("bbb","ccc") 

a = (1, 2, []) 
print(a)

a[2].append(1000)
print(a)

a[2].append(1000)
print(a)

a[2].append((100,10))
print(a)

a = (1, 2, 3)

b = a + (4, 5, 6)
print(b)

c = b[1:]
print(c)

b = b[1:]
print(b)

a = ("1", 2, True)
print(a)

**********

Output (first 500 chars):

**********
('a', 'b', 'c')
<class 'tuple'>
3
[('a', 'b'), ('a', 'c'), ('b', 'c'), ('c', 'c')]
('a', 'b')
a
(1, 2, [])
(1, 2, [1000])
(1, 2, [1000, 1000])
(1, 2, [1000, 1000, (100, 10)])
(1, 2, 3, 4, 5, 6)
(2, 3, 4, 5, 6)
(2, 3, 4, 5, 6)
('1', 2, True)

**********
No errors.
======================================================================
Script: loops.py

Contents:

**********
# FOR loops
for i in range(5):
    print(i)

my_list = [0, 2, "geronimo!", 3.0, True, False]
for k in my_list:
    print(k)

total = 0
summands = [0, 1, 11, 111, 1111]
for s in summands:
    total = total + s
    print(total)

# WHILE loop
z = 0
while z < 100:
    z = z + 1
    print(z)
**********

Output (first 500 chars):

**********
0
1
2
3
4
0
2
geronimo!
3.0
True
False
0
1
12
123
1234
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100

**********
No errors.
======================================================================
Script: basic_csv.py

Contents:

**********
import csv

# Read a file containing:
# 'Species','Infraorder','Family','Distribution','Body mass male (Kg)'
with open('../data/testcsv.csv','r') as f:

    csvread = csv.reader(f)
    temp = []
    for row in csvread:
        temp.append(tuple(row))
        print(row)
        print("The species is", row[0])

# write a file containing only species name and Body mass
with open('../data/testcsv.csv','r') as f:
    with open('../data/bodymass.csv','w') as g:

        csvread = csv.reader(f)
        csvwrite = csv.writer(g)
        for row in csvread:
            print(row)
            csvwrite.writerow([row[0], row[4]])

**********

Output (first 500 chars):

**********
['Species', 'Infraorder', 'Family', 'Distribution', 'Body mass male (Kg)']
The species is Species
['Panthera leo', 'Feliformia', 'Felidae', 'Africa', '190']
The species is Panthera leo
['Panthera tigris', 'Feliformia', 'Felidae', 'Asia', '220']
The species is Panthera tigris
['Canis lupus', 'Caniformia', 'Canidae', 'Northern Hemisphere', '45']
The species is Canis lupus
['Ursus arctos', 'Caniformia', 'Ursidae', 'Northern Hemisphere', '270']
The species is Ursus arctos
['Species', 'Infraorder', '
**********
No errors.
======================================================================
Script: align_seqs.py

Contents:

**********
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# align_seqs.py
from __future__ import annotations
from pathlib import Path
import csv
import re
import sys
from typing import Tuple, Optional

# Allowed DNA bases (A, C, G, T, case-insensitive)
_VALID_DNA = re.compile(r"^[ACGTacgt]+$")


def read_two_sequences(csv_path: Path) -> Tuple[str, str]:
    if not csv_path.exists():
        raise FileNotFoundError(f"Input file not found: {csv_path}")

    raw = csv_path.read_text(encoding="utf-8", errors="ignore")
    raw = raw.replace("\r\n", "\n").replace("\r", "\n").lstrip("\ufeff")

    tokens: list[str] = []

    # Try CSV parsing first
    from io import StringIO
    f = StringIO(raw)
    reader = csv.reader(f)
    for row in reader:
        for cell in row:
            cell = cell.strip().strip('"').strip("'")
            if cell:
                tokens.append(cell)

    # If nothing was found, split more loosely
    if not tokens:
        for line in raw.split("\n"):
            for cell in re.split(r"[,\t; ]+", line.strip()):
                if cell:
                    tokens.append(cell)

    def looks_like_dna(s: str) -> bool:
        return bool(re.fullmatch(r"[ACGTacgt]+", s))

    seqs = [t.upper() for t in tokens if looks_like_dna(t)]

    # Fallback: global regex extraction if still less than 2 sequences
    if len(seqs) < 2:
        seqs = re.findall(r"[ACGT]+", raw.upper())

    if len(seqs) < 2:
        raise ValueError("Could not find two valid DNA sequences in the input file.")

    return seqs[0], seqs[1]


def _looks_like_dna(s: str) -> bool:
    return bool(_VALID_DNA.match(s.replace(" ", "")))

def choose_long_short(a: str, b: str) -> Tuple[str, str]:
    # Return (longer, shorter)
    return (a, b) if len(a) >= len(b) else (b, a)


def calculate_score(s1: str, s2: str, start: int) -> Tuple[int, str]:
    l1, l2 = len(s1), len(s2)
    score = 0
    matched_marks = []

    # Uncomment for debugging:
    # import ipdb; ipdb.set_trace()

    for i in range(l2):
        j = i + start
        if j >= l1:
            break
        if s1[j] == s2[i]:
            score += 1
            matched_marks.append("*")
        else:
            matched_marks.append("-")

    return score, "".join(matched_marks)



def find_best_alignment(seq1: str, seq2: str) -> Tuple[str, str, int, int]:

    s1, s2 = choose_long_short(seq1, seq2)
    l1 = len(s1)

    best_score = -1
    best_align = ""
    best_start = 0

    for start in range(l1):
        score, _ = calculate_score(s1, s2, start)
        if score > best_score:
            best_score = score
            best_align = "." * start + s2
            best_start = start

    return best_align, s1, best_score, best_start


def write_report(out_path: Path, aligned_s2: str, s1: str, score: int, start: int) -> None:
    # Save the best alignment and score to a text file.
    out_path.parent.mkdir(parents=True, exist_ok=True)
    content = [
        "# Best overlap alignment\n",
        f"Start position: {start}\n",
        f"Score (matches): {score}\n",
        "\n",
        aligned_s2 + "\n",
        s1 + "\n",
        "\n",
        "# Legend: '.' = offset, '*' = match, '-' = mismatch (debug view)\n",
    ]
    out_path.write_text("".join(content), encoding="utf-8")



def main(in_file: Optional[str] = None, out_file: Optional[str] = None) -> int:
    here = Path(__file__).resolve().parent
    default_in = (here / "../data/align_seqs.csv").resolve()
    default_out = (here / "../results/best_alignment.txt").resolve()

    in_path = Path(in_file) if in_file else default_in
    out_path = Path(out_file) if out_file else default_out

    seq1, seq2 = read_two_sequences(in_path)
    aligned_s2, s1, best_score, best_start = find_best_alignment(seq1, seq2)
    write_report(out_path, aligned_s2, s1, best_score, best_start)

    # Print summary to terminal
    print(f"Input:  {in_path}")
    print(f"Output: {out_path}")
    print("Alignment:")
    print(aligned_s2)
    print(s1)
    print(f"Best score: {best_score} (start={best_start})")
    return 0


if __name__ == "__main__":

    args = sys.argv[1:]
    in_arg = args[0] if len(args) >= 1 else None
    out_arg = args[1] if len(args) >= 2 else None
    sys.exit(main(in_arg, out_arg))

**********

Output (first 500 chars):

**********
Input:  /home/mhasoba/Documents/Teaching/IC_CMEE/2025-26/Coursework/StudentRepos/XimanDing_xd1025/week2/data/align_seqs.csv
Output: /home/mhasoba/Documents/Teaching/IC_CMEE/2025-26/Coursework/StudentRepos/XimanDing_xd1025/week2/results/best_alignment.txt
Alignment:
CAATTCGGAT
ATCGCCGGATTACGGG
Best score: 5 (start=0)

**********
No errors.
======================================================================
Script: Vectorize2.R

Contents:

**********
# ============================================
# Vectorize2.R — Stochastic Ricker: loop vs vectorized
# ============================================

rm(list = ls())
set.seed(123)  # for reproducibility of the timing run

# --------------------------
# Slow baseline: double loop
# --------------------------
stochrick <- function(p0 = runif(1000, 0.5, 1.5),
                      r = 1.2, K = 1, sigma = 0.2,
                      numyears = 100) {

  # Matrix shape: rows = years, cols = populations
  N <- matrix(NA_real_, nrow = numyears, ncol = length(p0))
  N[1, ] <- p0

  if (numyears >= 2) {
    for (pop in 1:length(p0)) {             # loop over populations
      for (yr in 2:numyears) {              # loop over years
        eps <- rnorm(1, mean = 0, sd = sigma)
        Nt1 <- N[yr - 1, pop]
        N[yr, pop] <- Nt1 * exp(r * (1 - Nt1 / K) + eps)
      }
    }
  }
  N
}

# -------------------------------------------
# Vectorized across populations (fast version)
# One loop over time only; update all pops at once
# -------------------------------------------
stochrickvect <- function(p0 = runif(1000, 0.5, 1.5),
                          r = 1.2, K = 1, sigma = 0.2,
                          numyears = 100) {

  N <- matrix(NA_real_, nrow = numyears, ncol = length(p0))
  N[1, ] <- p0

  if (numyears >= 2) {
    for (yr in 2:numyears) {                # only time loop remains
      eps <- rnorm(length(p0), 0, sigma)     # vector of noises, one per population
      Nt1 <- N[yr - 1, ]                     # all populations at t-1
      growth <- r * (1 - Nt1 / K)
      N[yr, ] <- Nt1 * exp(growth + eps)     # vectorized update
    }
  }
  N
}

# --------------------------
# Benchmark & sanity checks
# --------------------------
cat("Stochastic Ricker (double loop) timing:\n")
print(system.time(res_loop <- stochrick()))

cat("Vectorized stochastic Ricker timing:\n")
print(system.time(res_vec  <- stochrickvect()))

# basic checks
stopifnot(all(dim(res_loop) == dim(res_vec)))
# the two runs won't be identical because they drew different random numbers;
# but shapes should match and values should be in reasonable ranges.

# Optional quick plot of a few trajectories (interactive)
# matplot(res_vec[ , 1:20], type = "l", lty = 1, col = 1,
#         xlab = "Year", ylab = "N", main = "20 stochastic Ricker trajectories")

cat("Done.\n")

**********

Output (first 500 chars):

**********
Stochastic Ricker (double loop) timing:
   user  system elapsed 
  0.123   0.012   0.134 
Vectorized stochastic Ricker timing:
   user  system elapsed 
  0.007   0.000   0.006 
Done.

**********
No errors.
======================================================================
Script: break.R

Contents:

**********
i <- 0 #Initialize i
while (i < Inf) {
  if (i == 10) {
    break 
  } else { # Break out of the while loop!  
    cat("i equals " , i , " \n")
    i <- i + 1 # Update i
  }
}
**********

Output (first 500 chars):

**********
i equals  0  
i equals  1  
i equals  2  
i equals  3  
i equals  4  
i equals  5  
i equals  6  
i equals  7  
i equals  8  
i equals  9  

**********
No errors.
======================================================================
Script: sample.R

Contents:

**********
######### Functions ##########

## A function to take a sample of size n from a population "popn" and return its mean
myexperiment <- function(popn,n) {
  pop_sample <- sample(popn, n, replace = FALSE)
  return(mean(pop_sample))
}

## Calculate means using a FOR loop on a vector without preallocation:
loopy_sample1 <- function(popn, n, num) {
  result1 <- vector() #Initialize empty vector of size 1 
  for(i in 1:num) {
    result1 <- c(result1, myexperiment(popn, n))
  }
  return(result1)
}

## To run "num" iterations of the experiment using a FOR loop on a vector with preallocation:
loopy_sample2 <- function(popn, n, num) {
  result2 <- vector(,num) #Preallocate expected size
  for(i in 1:num) {
    result2[i] <- myexperiment(popn, n)
  }
  return(result2)
}

## To run "num" iterations of the experiment using a FOR loop on a list with preallocation:
loopy_sample3 <- function(popn, n, num) {
  result3 <- vector("list", num) #Preallocate expected size
  for(i in 1:num) {
    result3[[i]] <- myexperiment(popn, n)
  }
  return(result3)
}


## To run "num" iterations of the experiment using vectorization with lapply:
lapply_sample <- function(popn, n, num) {
  result4 <- lapply(1:num, function(i) myexperiment(popn, n))
  return(result4)
}

## To run "num" iterations of the experiment using vectorization with sapply:
sapply_sample <- function(popn, n, num) {
  result5 <- sapply(1:num, function(i) myexperiment(popn, n))
  return(result5)
}

set.seed(12345)
popn <- rnorm(10000) # Generate the population
hist(popn)

n <- 100 # sample size for each experiment
num <- 10000 # Number of times to rerun the experiment

print("Using loops without preallocation on a vector took:" )
print(system.time(loopy_sample1(popn, n, num)))

print("Using loops with preallocation on a vector took:" )
print(system.time(loopy_sample2(popn, n, num)))

print("Using loops with preallocation on a list took:" )
print(system.time(loopy_sample3(popn, n, num)))

print("Using the vectorized sapply function (on a list) took:" )
print(system.time(sapply_sample(popn, n, num)))

print("Using the vectorized lapply function (on a list) took:" )
print(system.time(lapply_sample(popn, n, num)))

**********

Output (first 500 chars):

**********
[1] "Using loops without preallocation on a vector took:"
   user  system elapsed 
  0.192   0.010   0.203 
[1] "Using loops with preallocation on a vector took:"
   user  system elapsed 
  0.125   0.000   0.125 
[1] "Using loops with preallocation on a list took:"
   user  system elapsed 
  0.129   0.000   0.129 
[1] "Using the vectorized sapply function (on a list) took:"
   user  system elapsed 
  0.132   0.000   0.132 
[1] "Using the vectorized lapply function (on a list) took:"
   user  sys
**********
No errors.
======================================================================
Script: Vectorize1.R

Contents:

**********
M <- matrix(runif(1000000),1000,1000)

SumAllElements <- function(M) {
  Dimensions <- dim(M)
  Tot <- 0
  for (i in 1:Dimensions[1]) {
    for (j in 1:Dimensions[2]) {
      Tot <- Tot + M[i,j]
    }
  }
  return (Tot)
}

print("Using loops, the time taken is:")
print(system.time(SumAllElements(M)))

print("Using the in-built vectorized function, the time taken is:")
print(system.time(sum(M)))
**********

Output (first 500 chars):

**********
[1] "Using loops, the time taken is:"
   user  system elapsed 
  0.032   0.002   0.035 
[1] "Using the in-built vectorized function, the time taken is:"
   user  system elapsed 
  0.000   0.000   0.001 

**********
No errors.
======================================================================
Script: R_conditionals.R

Contents:

**********
# Checks if an integer is even
is.even <- function(n = 2) {
  if (n %% 2 == 0) {
    return(paste(n,'is even!'))
  } else {
    return(paste(n,'is odd!'))
  }
}

is.even(6)

#Test
print(is.even(6))   # 6 is even!
print(is.even(7))   # 7 is odd!

# Checks if a number is a power of 2
is.power2 <- function(n = 2) {
  if (log2(n) %% 1==0) {
    return(paste(n, 'is a power of 2!'))
  } else {
    return(paste(n,'is not a power of 2!'))
  }
}

is.power2(4)

#Test
print(is.power2(4))   # 4 is a power of 2!
print(is.power2(6))   # 6 is not a power of 2!

# Checks if a number is prime
is.prime <- function(n) {
  if (n==0) {
    return(paste(n,'is a zero!'))
  } else if (n==1) {
    return(paste(n,'is just a unit!'))
  }
  
  ints <- 2:(n-1)
  
  if (all(n%%ints!=0)) {
    return(paste(n,'is a prime!'))
  } else {
    return(paste(n,'is a composite!'))
  }
}

is.prime(3)

#Test
print(is.prime(3))   # 3 is a prime!
print(is.prime(9))   # 9 is a composite!
print(is.prime(1))   # 1 is just a unit!
**********

Output (first 500 chars):

**********
[1] "6 is even!"
[1] "6 is even!"
[1] "7 is odd!"
[1] "4 is a power of 2!"
[1] "4 is a power of 2!"
[1] "6 is not a power of 2!"
[1] "3 is a prime!"
[1] "3 is a prime!"
[1] "9 is a composite!"
[1] "1 is just a unit!"

**********
No errors.
======================================================================
Script: apply1.R

Contents:

**********
## Build a random matrix
M <- matrix(rnorm(100), 10, 10)

## Take the mean of each row
RowMeans <- apply(M, 1, mean)
print (RowMeans)

## Now the variance
RowVars <- apply(M, 1, var)
print (RowVars)

## By column
ColMeans <- apply(M, 2, mean)
print (ColMeans)

**********

Output (first 500 chars):

**********
 [1]  0.50148620 -0.03643097 -0.04395077 -0.22796126 -0.19120416 -0.18232260
 [7]  0.05027028  0.12983669 -0.07638737 -0.17997700
 [1] 1.1429778 0.3307331 1.2066688 0.9463175 1.2948709 0.4623646 0.3707802
 [8] 0.6640058 1.0196877 0.6010853
 [1]  0.14642254 -0.68100404  0.16058999  0.10008238  0.03508291 -0.26925946
 [7] -0.17821706  0.26639205 -0.17727240  0.34054215

**********
No errors.
======================================================================
Script: basic_io.R

Contents:

**********
# A simple script to illustrate R input-output.  
# Run line by line and check inputs outputs to understand what is happening  

MyData <- read.csv("../data/trees.csv", header = TRUE) # import with headers

write.csv(MyData, "../results/MyData.csv") #write it out as a new file

write.table(MyData[1,], file = "../results/MyData.csv",append=TRUE) # Append to it

write.csv(MyData, "../results/MyData.csv", row.names=TRUE) # write row names

write.table(MyData, "../results/MyData.csv", col.names=FALSE) # ignore column names
**********

Output (first 500 chars):

**********

**********
Errors:
**********
Warning message:
In write.table(MyData[1, ], file = "../results/MyData.csv", append = TRUE) :
  appending column names to file

**********
======================================================================
Script: Florida.R

Contents:

**********
## Florida.R — Is Florida getting warmer?
## Following the steps from the Practicals: correlation + permutation test
## Before running: set working directory to code/, and ensure ../data/KeyWestAnnualMeanTemperature.RData exists

rm(list = ls())

## 1) Load and inspect the data (Key West annual mean temperature dataset)
load("../data/KeyWestAnnualMeanTemperature.RData")  # Loads an object named 'ats'
stopifnot(exists("ats"))
# Optional: quick inspection
print(class(ats)); print(head(ats)); plot(ats)  # The book suggests checking structure and trend with ls(), class(), head(), plot(ats)

## 2) Compute the observed correlation coefficient between Year and Temperature (Pearson)
r_obs <- cor(ats$Year, ats$Temp, method = "pearson", use = "complete.obs")

## 3) Permutation test: randomly shuffle the temperature values among years
##    Each time, recompute the correlation and store it
##    Use sample() for randomization, and set.seed() for reproducibility
set.seed(123)           # Ensures reproducible results
B <- 10000              # Number of permutations; increase if needed
r_perm <- numeric(B)

for (b in 1:B) {
  r_perm[b] <- cor(ats$Year,
                   sample(ats$Temp, replace = FALSE),  # Shuffle pairing only, no resampling
                   method = "pearson")
}

## 4) Compute p-values
## One-sided test (warming hypothesis H1: r > 0):
p_one <- mean(r_perm >= r_obs)
## Two-sided test (any trend):
p_two <- mean(abs(r_perm) >= abs(r_obs))

## 5) Visualize the permutation null distribution and the observed correlation
hist(r_perm,
     main = "Permutation null distribution for r(Year, Temp)",
     xlab = "r under H0 (temperatures randomly assigned to years)")
abline(v = r_obs, lwd = 2)
legend("topleft",
       legend = c(paste0("observed r = ", round(r_obs, 3)),
                  paste0("one-sided p = ", signif(p_one, 3)),
                  paste0("two-sided p = ", signif(p_two, 3))),
       bty = "n")

## 6) Print results to console
cat("\nObserved Pearson r:", r_obs,
    "\nOne-sided p (warming):", p_one,
    "\nTwo-sided p:", p_two, "\n")

**********

Output (first 500 chars):

**********

**********
Errors:
**********
Error in readChar(con, 5L, useBytes = TRUE) : cannot open the connection
Calls: load -> readChar
In addition: Warning message:
In readChar(con, 5L, useBytes = TRUE) :
  cannot open compressed file '../data/KeyWestAnnualMeanTemperature.RData', probable reason 'No such file or directory'
Execution halted

**********
======================================================================
Script: boilerplate.R

Contents:

**********
# A boilerplate R script

MyFunction <- function(Arg1, Arg2) {
  
  # Statements involving Arg1, Arg2:
  print(paste("Argument", as.character(Arg1), "is a", class(Arg1))) # print Arg1's type
  print(paste("Argument", as.character(Arg2), "is a", class(Arg2))) # print Arg2's type
  
  return (c(Arg1, Arg2)) #this is optional, but very useful
}

MyFunction(1,2) #test the function
MyFunction("Riki","Tiki") #A different test
**********

Output (first 500 chars):

**********
[1] "Argument 1 is a numeric"
[1] "Argument 2 is a numeric"
[1] 1 2
[1] "Argument Riki is a character"
[1] "Argument Tiki is a character"
[1] "Riki" "Tiki"

**********
No errors.
======================================================================
Script: apply2.R

Contents:

**********
SomeOperation <- function(v) { # (What does this function do?)
  if (sum(v) > 0) { #note that sum(v) is a single (scalar) value
    return (v * 100)
  } else { 
    return (v)
  }
}


M <- matrix(rnorm(100), 10, 10)
print (apply(M, 1, SomeOperation))


**********

Output (first 500 chars):

**********
            [,1]       [,2]       [,3]       [,4]        [,5]       [,6]
 [1,]  148.84477 167.328067 -1.2309719 -1.5898897  0.14733504 -0.5534020
 [2,]    2.22608 -95.990122 -0.1499325 -0.6465427  0.03143235 -0.3653270
 [3,]  106.20486 -27.202754 -0.5889288 -0.1222836 -0.83044205  0.1372080
 [4,]   29.85792 -69.826510 -0.3988780 -1.5564839  0.13433951 -2.3758059
 [5,]  237.71906  63.295575 -0.5628297 -1.0376385  0.03526848  0.2382730
 [6,]  -71.83464 -91.864308  1.1741386 -0.2591517 -2.53537225 
**********
No errors.
======================================================================
Script: control_flow.R

Contents:

**********
# =========================
# control_flow.R
# Basic control flow examples: if / for / while
# =========================

cat("== IF EXAMPLES ==\n")
a <- TRUE
if (a == TRUE) {
  cat("a is TRUE\n")
} else {
  cat("a is FALSE\n")
}

z <- runif(1)  # random number between 0 and 1
if (z <= 0.5) {
  cat("z <= 0.5\n")
} else {
  cat("z > 0.5\n")
}

cat("\n== FOR LOOP: SQUARE NUMBERS ==\n")
for (i in 1:10) {
  j <- i * i
  cat(i, "squared is", j, "\n")
}

cat("\n== FOR LOOP: ITERATE THROUGH VECTOR ==\n")
v1 <- c("a", "bc", "def")
for (x in v1) {
  cat("element:", x, "\n")
}

cat("\n== WHILE LOOP: 1^2 TO 10^2 ==\n")
i <- 0
while (i < 10) {
  i <- i + 1
  cat(i^2, "\n")
}

cat("\n== WHILE LOOP WITH SAFETY AND next/break ==\n")
i <- 0
step <- 0
while (TRUE) {
  i <- i + 1
  step <- step + 1
  
  # skip even numbers
  if (i %% 2 == 0) {
    next
  }
  
  cat("odd i:", i, "\n")
  
  # stop the loop when i >= 9
  if (i >= 9) {
    cat("Reached i >= 9, breaking loop\n")
    break
  }
  
  # safety break to avoid infinite loop
  if (step > 1000) {
    warning("Too many steps — breaking to avoid infinite loop")
    break
  }
}

cat("\nScript complete!\n")

**********

Output (first 500 chars):

**********
== IF EXAMPLES ==
a is TRUE
z <= 0.5

== FOR LOOP: SQUARE NUMBERS ==
1 squared is 1 
2 squared is 4 
3 squared is 9 
4 squared is 16 
5 squared is 25 
6 squared is 36 
7 squared is 49 
8 squared is 64 
9 squared is 81 
10 squared is 100 

== FOR LOOP: ITERATE THROUGH VECTOR ==
element: a 
element: bc 
element: def 

== WHILE LOOP: 1^2 TO 10^2 ==
1 
4 
9 
16 
25 
36 
49 
64 
81 
100 

== WHILE LOOP WITH SAFETY AND next/break ==
odd i: 1 
odd i: 3 
odd i: 5 
odd i: 7 
odd i: 9 
Reached i >= 9, bre
**********
No errors.
======================================================================
Script: Ricker.R

Contents:

**********
Ricker <- function(N0=1, r=1, K=10, generations=50)
{
  # Runs a simulation of the Ricker model
  # Returns a vector of length generations
  
  N <- rep(NA, generations)    # Creates a vector of NA
  
  N[1] <- N0
  for (t in 2:generations)
  {
    N[t] <- N[t-1] * exp(r*(1.0-(N[t-1]/K)))
  }
  return (N)
}

plot(Ricker(generations=10), type="l")
**********

Output (first 500 chars):

**********

**********
No errors.
======================================================================
Script: TreeHeight.R

Contents:

**********
# TreeHeight.R
#
# Reads trees.csv and calculates tree heights for all trees in the data.
# Output into TreeHts.csv in results file 
# TreeHts.csv will contain the calculated tree heights along with the original data in the following format.
# Works with source() and Rscript.

# Original content in TreeHeight.R document 
# height = distance * tan(degrees * pi/180)
TreeHeight <- function(degrees, distance) {
  radians <- degrees * pi / 180
  height <- distance * tan(radians)
  return(height)
}

# Read the data using a relative path (Hint in question)
MyData <- read.csv("../data/trees.csv", header = TRUE)

# Calculate tree heights (in meters) and add as a new column
MyData$Tree.Height.m <- TreeHeight(MyData$Angle.degrees, MyData$Distance.m)

# Write the result to the results directory using a relative path
write.csv(MyData, "../results/TreeHts.csv", row.names = FALSE)

# Optional confirmation message
print("Done! Wrote ../results/TreeHts.csv")

**********

Output (first 500 chars):

**********
[1] "Done! Wrote ../results/TreeHts.csv"

**********
No errors.
======================================================================
Script: next.R

Contents:

**********
for (i in 1:10) {
  if ((i %% 2) == 0) # check if the number is odd
    next # pass to next iteration of loop 
  print(i)
}

cat("Loop complete!\n")
**********

Output (first 500 chars):

**********
[1] 1
[1] 3
[1] 5
[1] 7
[1] 9
Loop complete!

**********
No errors.
======================================================================
Script: preallocate.R

Contents:

**********
# ====================================
# preallocate.R (clean benchmark for x = 1000)
# Compare timing with and without pre-allocation (no prints inside loops)
# ====================================

NoPreallocFun <- function(x) {
  a <- vector()  # empty vector
  for (i in 1:x) {
    a <- c(a, i) # repeated resize
  }
  a
}

PreallocFun <- function(x) {
  a <- rep(NA, x)  # pre-allocated vector
  for (i in 1:x) {
    a[i] <- i      # in-place assignment
  }
  a
}

x <- 1000

cat("== Timing without pre-allocation ==\n")
print(system.time(NoPreallocFun(x)))

cat("== Timing with pre-allocation ==\n")
print(system.time(PreallocFun(x)))

**********

Output (first 500 chars):

**********
== Timing without pre-allocation ==
   user  system elapsed 
  0.008   0.001   0.009 
== Timing with pre-allocation ==
   user  system elapsed 
  0.002   0.000   0.001 

**********
No errors.

======================================================================
FEEDBACK SUMMARY
======================================================================

Scripts tested: 46
Scripts successful: 37
Scripts with errors: 9
Warnings/Notes: 1

IMPORTANT DEBUGGING GUIDANCE:
------------------------------

Please review all warnings and errors, and your directory structure based on the above log.

Ask yourself: Why did I not get these warnings or errors on my machine when I tested my code?
Common reasons for environment differences:

• File paths: Your local machine may have different directory structures
• Dependencies: Missing packages or different versions
• File permissions: Scripts may not be executable on the testing server
• Case sensitivity: Linux systems are case-sensitive (your laptop may not be)
• Working directory: Scripts may assume they run from a specific location
• Input files: Required data files may be missing or in wrong locations

Debugging steps:
1. Test your code in a clean environment (fresh directory)
2. Check all file paths are relative and correct
3. Verify all required files are present and properly named
4. Test on a case-sensitive system if possible
5. Run your scripts from different directories to check robustness

Fix these issues and test again. Good debugging skills are essential for scientific computing!

